import attr
import matplotlib.pyplot as plt

from V6Gene.Trie import Trie
from V6Gene.Generator.Helper import Helper
from V6Gene.Generator.RandomGenerator import RandomGenerator
from V6Gene.Generator.Converter import Converter
from typing import Dict


@attr.s
class V6Generator:
    # Helper parameters
    prefix_quantity = attr.ib(type=int)
    rgr = attr.ib(type=float)
    depth_distribution = attr.ib(factory=dict, type=Dict)
    level_distribution = attr.ib(factory=dict, type=Dict)
    input_prefixes = attr.ib(factory=list, type=list)
    Help = attr.ib(default=Helper(), type=Helper)

    # Parameters for generating
    _binary_trie = attr.ib(default=Trie.Trie(), type=Trie)
    _randomly_generated_prefixes = attr.ib(default=0, type=int)
    _generated_traversing_trie = attr.ib(default=0, type=int)

    # Result prefixes
    _generated_prefixes_list = attr.ib(factory=list, type=list)

    def __attrs_post_init__(self) -> None:
        """Initialize other generator class attributes.
        :return: None
        """
        #  Construct the seed prefix trie
        for prefix in self.input_prefixes:
            self._binary_trie.add_node(Helper.get_binary_prefix(prefix))

        # Set leaf nodes in binary trie
        self._binary_trie.preorder(self._binary_trie.root_node, "statistic")

        # Calculate number of prefixes that will be generated randomly (without using the seed prefix trie)
        self._randomly_generated_prefixes = int(float(self.prefix_quantity) * self.rgr / 100)

        # Calculate number of prefixes that will be generated by traversing of seed prefix trie
        self._generated_traversing_trie = self.prefix_quantity - self._randomly_generated_prefixes

        # Check if generating based on depth and level parameter is even possible
        self._check_depth_distribution()
        self._check_level_distribution()

        # Initialize helper class
        self.help_init()
        self._binary_trie.Help = self.Help
        self._binary_trie.max_possible_level = self._max_level()

        # Create output graphs
        self.create_depth_distributing_graph("depth_distributing_before_generating.svg")

    def help_init(self):
        self.Help.start_depth_distribution = self._binary_trie.full_prefix_nodes
        self.Help.final_depth_distribution = self.depth_distribution
        self.Help.leafs_prefixes = self._binary_trie.prefix_leaf_nodes

        self.Help.create_distributing_plan()
        self.Help.create_distributing_strategy(self._binary_trie.prefix_leaf_nodes)

    def start_generating(self):
        # print(f"level before generaiting: {self._binary_trie._max_trie_level}")
        # print(f"TRIE TRAVERSAL prefixes: {self._generated_traversing_trie}")
        # print(f"RANDOM prefixes: {self._randomly_generated_prefixes}")
        # print(f"RANDOM PLAN -> {Helper.distribution_random_plan}")
        print(f"start number of prefixes ===> {self._binary_trie.prefix_nodes}")
        self._binary_trie.preorder(self._binary_trie.root_node, "generate")
        # print(f"level after generaiting: {self._binary_trie._max_trie_level}")

        # second phase of generating - random generating
        Randomizer = RandomGenerator(self._binary_trie, distribution_plan=Helper.distribution_random_plan)
        Randomizer.random_generate()

        new_prefixes = set(self._binary_trie.path(self._binary_trie.root_node))

        output_converter = Converter(new_prefixes)
        converted_prefixes = output_converter.convert_prefixes()

        for prefix in converted_prefixes:
            print(prefix)

        # self.create_depth_distributing_graph("depth_distributing_after_generating.svg")

    def create_depth_distributing_graph(self, graph_name) -> None:
        """Create inputs and outputs graphs using current state of binary trie.

        :param graph_name: string; name of graph
        :return: None
        """
        x = []

        for p_len in self._binary_trie.prefix_nodes.keys():
            x.append(p_len)

        prefix_num = list(self._binary_trie.prefix_nodes.values())
        plt.figure(figsize=(15, 15))
        plt.bar(x, prefix_num, align='center', alpha=1,)

        plt.xlabel("Prefix length")
        plt.ylabel("Number of prefixes")
        plt.title("Depth distribution before generating", fontweight='bold')

        plt.xticks([i for i in range(max(x)+1)])
        plt.yticks([i for i in range(100)])

        plt.savefig('graphs/' + graph_name, format='svg', dpi=1200)

    def _check_depth_distribution(self) -> None:
        """Check input parameter depth distribution.
        Check input parameter and control if generating is even possible

        :return: None
        """
        new_prefixes_num = 0

        initiate_distribution = self.Help.group_by_length(self._binary_trie.full_prefix_nodes)  # dictionary statistic from previous function
        final_distribution = self.Help.group_by_length(self.depth_distribution)
        tmp_random = self._randomly_generated_prefixes

        print(self.Help.group_by_length(self._binary_trie.prefix_leaf_nodes))

        for i in range(len(initiate_distribution)):

            start = initiate_distribution[i]['prefixes_num']
            end = final_distribution[i]['prefixes_num']

            # Calculate how many prefixes should be generated on current i level
            new_prefixes_num = end - start

            # no changes; Deep check is necessary here
            if new_prefixes_num == 0:
                continue

            # deleting prefixes
            if new_prefixes_num < 0:
                raise ValueError(f"Cannot delete prefixes from {i} level")

            # RIR level and RIR already exists in trie -> Random
            if i == 0 and new_prefixes_num != 0:
                if new_prefixes_num <= tmp_random:
                    tmp_random -= new_prefixes_num
                    continue
                else:
                    raise ValueError(f"Cannot generate prefixes on  depth level {i}")
            else:
                # If exists some leafs nodes on previous depth level -> prefixes will be generated from them
                print(f"LEAFS -> {self.Help.group_by_length(self._binary_trie.prefix_leaf_nodes)[i-1]}")
                if self.Help.group_by_length(self._binary_trie.prefix_leaf_nodes)[i-1]['prefixes_num'] > 0:
                    continue

                # No leafs. Look if we can generate this prefixes in random process
                else:
                    if initiate_distribution[i]['prefixes_num'] != 0 and new_prefixes_num <= tmp_random:
                        tmp_random -= new_prefixes_num
                        continue
                    else:
                        raise ValueError(f"Cannot generate prefixes on  depth level {i}")

        for depth, prefixes_num in self.depth_distribution.items():
            current_value = self._binary_trie.prefix_nodes.get(depth)

            if prefixes_num < 0:
                raise ValueError("Number of prefixes can't be less than zero")

            if depth < 0:
                raise ValueError("Level value can't be less than zero")

            if current_value is None:  # depth doesn't exist in trie
                # Set number of prefixes on this depth as 0
                current_value = 0

            # input distribution contains less prefixes than already are in trie on the same depth
            if prefixes_num - current_value < 0:
                raise ValueError("Number of prefixes on generated depth can't be less than current number")

            # calculate number of prefixes which should be generated for current depth
            new_prefixes_num += prefixes_num - current_value

        if new_prefixes_num > self.prefix_quantity:
            raise ValueError("Generated prefixes num is greater than expected")

    def _check_level_distribution(self):
        if self._binary_trie.init_max_level > self._max_level():
            raise ValueError("Current max trie level more than max lvl from level distribution parameter")

        # if self._binary_trie.init_max_level == self._max_level():
        #     raise ValueError("Current max trie level is already equal to max lvl from level distribution param. Generating isn't possible")

        for level, prefixes_num in self.level_distribution.items():
            trie_prefixes = self._binary_trie.level_distribution.get(level)

            if trie_prefixes > prefixes_num:
                raise ValueError(f"Number of prefixes on generated level {level} can't be less than current number")

    def _max_level(self):
        max_level = 0

        for key in self.level_distribution.keys():
            if self.level_distribution[key] != 0 and key > max_level:
                max_level = key

        return max_level
